<!DOCTYPE html>
<html lang="vi">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SubRealtime - Nh·∫≠n d·∫°ng v√† d·ªãch gi·ªçng n√≥i th·ªùi gian th·ª±c</title>
	<style>
		:root {
			--primary-color: #4a148c;
			--secondary-color: #7b1fa2;
			--text-color: #f5f5f5;
			--background-dark: #121212;
			--background-light: #1e1e1e;
			--accent-color: #aa00ff;
			--danger-color: #d32f2f;
			--success-color: #388e3c;
			--warning-color: #f57f17;
			--info-color: #0288d1;
		}

		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			margin: 0;
			padding: 0;
			background-color: var(--background-dark);
			color: var(--text-color);
			line-height: 1.6;
		}

		.container {
			max-width: 900px;
			margin: 0 auto;
			padding: 20px;
		}

		header {
			text-align: center;
			padding: 10px 0;
			margin-bottom: 20px;
			border-bottom: 1px solid var(--accent-color);
		}

		h1 {
			margin: 0;
			color: var(--accent-color);
		}

		.status-bar {
			background-color: var(--background-light);
			padding: 10px;
			margin-bottom: 15px;
			border-radius: 5px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.status-message {
			flex-grow: 1;
		}

		.status-bar.recording {
			background-color: rgba(170, 0, 255, 0.3);
			border-left: 4px solid var(--accent-color);
		}

		.status-bar.error {
			background-color: rgba(211, 47, 47, 0.3);
			border-left: 4px solid var(--danger-color);
		}

		.status-bar.success {
			background-color: rgba(56, 142, 60, 0.3);
			border-left: 4px solid var(--success-color);
		}

		.status-bar.warning {
			background-color: rgba(245, 127, 23, 0.3);
			border-left: 4px solid var(--warning-color);
		}

		.status-bar.info {
			background-color: rgba(2, 136, 209, 0.3);
			border-left: 4px solid var(--info-color);
		}

		.status-bar.processing {
			background-color: rgba(3, 169, 244, 0.3);
			border-left: 4px solid #03a9f4;
		}

		.language-tabs {
			display: flex;
			margin-bottom: 15px;
			border-radius: 5px;
			overflow: hidden;
			background-color: var(--background-light);
		}

		.language-tab {
			flex-grow: 1;
			padding: 10px;
			text-align: center;
			cursor: pointer;
			border: none;
			background-color: var(--background-light);
			color: var(--text-color);
			transition: all 0.3s ease;
		}

			.language-tab:hover {
				background-color: rgba(170, 0, 255, 0.3);
			}

			.language-tab.active {
				background-color: var(--accent-color);
				color: white;
			}

		.action-buttons {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-bottom: 15px;
		}

		.btn {
			padding: 10px 15px;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 5px;
			background-color: var(--primary-color);
			color: white;
			transition: all 0.3s ease;
			min-width: 120px;
		}

			.btn:hover {
				background-color: var(--secondary-color);
				transform: translateY(-2px);
			}

		.btn-mic {
			background-color: var(--accent-color);
		}

			.btn-mic.active {
				background-color: var(--danger-color);
				animation: pulse 1.5s infinite;
			}

		@keyframes pulse {
			0% {
				box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7);
			}

			70% {
				box-shadow: 0 0 0 10px rgba(211, 47, 47, 0);
			}

			100% {
				box-shadow: 0 0 0 0 rgba(211, 47, 47, 0);
			}
		}

		.btn-clear {
			background-color: var(--danger-color);
		}

		.btn-correct {
			background-color: var(--success-color);
		}

		.btn-translate {
			background-color: var(--info-color);
		}

		.btn-vocab {
			background-color: var(--warning-color);
		}

		.content-box {
			background-color: var(--background-light);
			padding: 15px;
			border-radius: 5px;
			margin-bottom: 15px;
		}

			.content-box h3 {
				margin-top: 0;
				color: var(--accent-color);
				border-bottom: 1px solid rgba(170, 0, 255, 0.3);
				padding-bottom: 5px;
			}

		.result-box {
			min-height: 80px;
			white-space: pre-wrap;
		}

		.corrected-box, .translation-box, .vocab-box {
			border-left: 4px solid var(--accent-color);
		}

		.hidden {
			display: none;
		}

		textarea {
			width: 100%;
			padding: 10px;
			background-color: var(--background-dark);
			border: 1px solid #333;
			border-radius: 5px;
			color: var(--text-color);
			min-height: 120px;
			resize: vertical;
		}

		@media (max-width: 768px) {
			.action-buttons {
				flex-direction: column;
			}

			.btn {
				width: 100%;
			}
		}

		/* Vocab table styling */
		table {
			width: 100%;
			border-collapse: collapse;
			margin-top: 10px;
		}

		th, td {
			padding: 8px;
			border: 1px solid #333;
		}

		th {
			background-color: var(--background-dark);
			color: var(--accent-color);
		}

		tr:nth-child(even) {
			background-color: rgba(0, 0, 0, 0.2);
		}
	</style>
</head>
<body>
	<div class="container">
		<header>
			<h1>SubRealtime</h1>
			<p>Nh·∫≠n d·∫°ng gi·ªçng n√≥i th·ªùi gian th·ª±c v·ªõi ch·ªânh s·ª≠a v√† d·ªãch thu·∫≠t</p>
		</header>

		<div id="statusBar" class="status-bar">
			<span id="statusMessage" class="status-message">S·∫µn s√†ng</span>
		</div>

		<div class="language-tabs">
			<button id="langVi" class="language-tab active" onclick="onLanguageTabClick('vi-VN')">üáªüá≥ Ti·∫øng Vi·ªát</button>
			<button id="langEn" class="language-tab" onclick="onLanguageTabClick('en-US')">üá∫üá∏ Ti·∫øng Anh</button>
			<button id="langJa" class="language-tab" onclick="onLanguageTabClick('ja-JP')">üáØüáµ Ti·∫øng Nh·∫≠t</button>
		</div>

		<div class="action-buttons">
			<button id="micButton" class="btn btn-mic" onclick="onMicButtonClick()">
				üéôÔ∏è Ghi √¢m
			</button>
			<button id="correctionButton" class="btn btn-correct" onclick="onCorrectionButtonClick()">
				‚úèÔ∏è Ch·ªânh s·ª≠a
			</button>
			<button id="translateButton" class="btn btn-translate" onclick="onTranslateButtonClick()">
				üîÑ D·ªãch
			</button>
			<button id="vocabButton" class="btn btn-vocab" onclick="onVocabButtonClick()">
				üìö T·ª´ v·ª±ng
			</button>
			<button id="saveButton" class="btn" onclick="onSaveButtonClick()">
				üíæ L∆∞u
			</button>
			<button id="clearButton" class="btn btn-clear" onclick="onClearButtonClick()">
				üóëÔ∏è X√≥a t·∫•t c·∫£
			</button>
		</div>

		<div id="resultContainer" class="content-box">
			<h3>Nh·∫≠n d·∫°ng gi·ªçng n√≥i</h3>
			<div id="resultBox" class="result-box"></div>
		</div>

		<div id="correctedContainer" class="content-box corrected-box hidden">
			<h3>ƒê√£ ch·ªânh s·ª≠a</h3>
			<div id="correctedBox" class="result-box"></div>
		</div>

		<div id="translationContainer" class="content-box translation-box hidden">
			<h3>B·∫£n d·ªãch <button id="speakButton" class="btn" onclick="onSpeakButtonClick()">üîä Ph√°t √¢m</button></h3>
			<div id="translationText" class="result-box"></div>
		</div>

		<div id="vocabContainer" class="content-box vocab-box hidden">
			<h3>T·ª´ v·ª±ng g·ª£i √Ω</h3>
			<div id="vocabList"></div>
		</div>

		<div class="content-box">
			<h3>So·∫°n th·∫£o vƒÉn b·∫£n</h3>
			<textarea id="editableText" placeholder="N·ªôi dung c√≥ th·ªÉ ch·ªânh s·ª≠a ·ªü ƒë√¢y..."></textarea>
		</div>
	</div>

	<script>
        const GEMINI_API_KEY = "AIzaSyDaROReiR48rjfavf8Lk6XvphC6QxKPZo4";
		// Initialize currentLang with default language

        // --- C√ÅC BI·∫æN TR·∫†NG TH√ÅI CH√çNH ---
        let isRecording = false;            // ƒêang ghi √¢m hay kh√¥ng
        let finalTranscript = '';           // K·∫øt qu·∫£ nh·∫≠n d·∫°ng cu·ªëi c√πng
        let interimTranscript = '';         // K·∫øt qu·∫£ t·∫°m th·ªùi trong qu√° tr√¨nh nh·∫≠n d·∫°ng
        let correctedText = '';             // VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a ng·ªØ ph√°p
        let translatedText = '';            // VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c d·ªãch
        let currentLang = 'vi-VN';          // Ng√¥n ng·ªØ hi·ªán t·∫°i
        let recognitionStoppedManually = false; // Ki·ªÉm so√°t d·ª´ng th·ªß c√¥ng
        let recognition = null;             // ƒê·ªëi t∆∞·ª£ng nh·∫≠n d·∫°ng gi·ªçng n√≥i

        // --- QU·∫¢N L√ù DOM ELEMENTS ---
        const elements = {
            statusBar: document.getElementById('statusBar'),
            statusMessage: document.getElementById('statusMessage'),
            resultBox: document.getElementById('resultBox'),
            correctedBox: document.getElementById('correctedBox'),
            correctedContainer: document.getElementById('correctedContainer'),
            translationText: document.getElementById('translationText'),
            translationContainer: document.getElementById('translationContainer'),
            vocabList: document.getElementById('vocabList'),
            vocabContainer: document.getElementById('vocabContainer'),
            editableText: document.getElementById('editableText'),
            micButton: document.getElementById('micButton'),
            translationBox: document.getElementById('translationContainer'),
            vocabBox: document.getElementById('vocabContainer'),
            langTabs: {
                vi: document.getElementById('langVi'),
                en: document.getElementById('langEn'),
                ja: document.getElementById('langJa')
            }
        };

        // --- KH·ªûI T·∫†O NH·∫¨N D·∫†NG GI·ªåNG N√ìI ---
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showStatus('error', 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ nh·∫≠n di·ªán gi·ªçng n√≥i');
                return false;
            }

            try {
                // T·∫°o ƒë·ªëi t∆∞·ª£ng nh·∫≠n d·∫°ng
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();

                // C·∫•u h√¨nh
                recognition.lang = currentLang;
                recognition.interimResults = true;  // Cho ph√©p k·∫øt qu·∫£ t·∫°m th·ªùi
                recognition.continuous = true;      // Nh·∫≠n d·∫°ng li√™n t·ª•c
                recognition.maxAlternatives = 3;    // S·ªë l∆∞·ª£ng ph∆∞∆°ng √°n thay th·∫ø

                // X·ª≠ l√Ω c√°c s·ª± ki·ªán
                recognition.onresult = handleRecognitionResult;
                recognition.onstart = handleRecognitionStart;
                recognition.onend = handleRecognitionEnd;
                recognition.onerror = handleRecognitionError;

                return true;
            } catch (error) {
                console.error("L·ªói kh·ªüi t·∫°o nh·∫≠n d·∫°ng gi·ªçng n√≥i:", error);
                showStatus('error', `L·ªói kh·ªüi t·∫°o: ${error.message}`);
                return false;
            }
        }

        // --- X·ª¨ L√ù K·∫æT QU·∫¢ NH·∫¨N D·∫†NG ---
        function handleRecognitionResult(event) {
            // X·ª≠ l√Ω k·∫øt qu·∫£ th√¥ t·ª´ API Web Speech
            let interimResult = '';
            let finalResult = '';

            // L·ªçc k·∫øt qu·∫£ t·∫°m th·ªùi v√† ch√≠nh th·ª©c
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript.trim();
                if (event.results[i].isFinal) {
                    // K·∫øt qu·∫£ cu·ªëi c√πng
                    finalResult += transcript + ' ';
                } else {
                    // K·∫øt qu·∫£ t·∫°m th·ªùi khi ƒëang n√≥i
                    interimResult += transcript + ' ';
                }
            }

            // C·∫≠p nh·∫≠t k·∫øt qu·∫£ cu·ªëi c√πng n·∫øu c√≥
            if (finalResult) {
                finalTranscript += finalResult;
                // Hi·ªÉn th·ªã trong box nh·∫≠n di·ªán
                elements.resultBox.textContent = finalTranscript.trim();
                // L∆ØU √ù: KH√îNG t·ª± ƒë·ªông ch·ªânh s·ª≠a ho·∫∑c d·ªãch ·ªü ƒë√¢y nh∆∞ tr∆∞·ªõc
            }

            // C·∫≠p nh·∫≠t k·∫øt qu·∫£ t·∫°m th·ªùi khi ƒëang n√≥i
            if (interimResult) {
                interimTranscript = interimResult;
                // Hi·ªÉn th·ªã tr·ª±c ti·∫øp trong box realtime
                elements.resultBox.textContent = finalTranscript + ' ' + interimTranscript;
                elements.resultBox.classList.remove('hidden');
            }
        }

        // --- B·∫ÆT ƒê·∫¶U NH·∫¨N D·∫†NG ---
        function startRecognition() {
            try {
                if (!recognition) {
                    if (!initSpeechRecognition()) return;
                }

                // C·∫•u h√¨nh ng√¥n ng·ªØ hi·ªán t·∫°i
                recognition.lang = currentLang;

                // B·∫Øt ƒë·∫ßu ghi √¢m
                recognition.start();
                isRecording = true;
                recognitionStoppedManually = false;

                // C·∫≠p nh·∫≠t UI
                updateMicButtonState(true);
                showStatus('recording', 'ƒêang nghe... ');

            } catch (error) {
                console.error("L·ªói khi b·∫Øt ƒë·∫ßu nh·∫≠n d·∫°ng:", error);
                showStatus('error', `Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu ghi √¢m: ${error.message}`);
            }
        }

        // --- D·ª™NG NH·∫¨N D·∫†NG ---
        function stopRecognition() {
            try {
                recognitionStoppedManually = true;
                if (recognition) {
                    recognition.stop();
                }

                // C·∫≠p nh·∫≠t tr·∫°ng th√°i
                isRecording = false;

                // C·∫≠p nh·∫≠t UI
                updateMicButtonState(false);
                showStatus('ready', 'ƒê√£ d·ª´ng ghi √¢m');

                // Hi·ªÉn th·ªã k·∫øt qu·∫£ cu·ªëi c√πng (bao g·ªìm c·∫£ t·∫°m th·ªùi n·∫øu c√≥)
                if (interimTranscript.trim()) {
                    finalTranscript += interimTranscript.trim() + ' ';
                    elements.resultBox.textContent = finalTranscript.trim();
                    interimTranscript = '';
                }
            } catch (error) {
                console.error("L·ªói khi d·ª´ng nh·∫≠n d·∫°ng:", error);
                showStatus('error', `L·ªói khi d·ª´ng ghi √¢m: ${error.message}`);
            }
        }

        // --- X·ª¨ L√ù KHI NH·∫¨N D·∫†NG K·∫æT TH√öC ---
        function handleRecognitionEnd() {
            isRecording = false;
            updateMicButtonState(false);

            // X·ª≠ l√Ω k·∫øt qu·∫£ t·∫°m th·ªùi c√≤n l·∫°i n·∫øu c√≥
            if (interimTranscript.trim()) {
                finalTranscript += interimTranscript.trim() + ' ';
                elements.resultBox.textContent = finalTranscript.trim();
                interimTranscript = '';
            }

            // Kh√¥ng t·ª± ƒë·ªông l∆∞u v√†o editable box
            // Kh√¥ng t·ª± ƒë·ªông ch·ªânh s·ª≠a ho·∫∑c d·ªãch

            // T·ª± ƒë·ªông kh·ªüi ƒë·ªông l·∫°i n·∫øu kh√¥ng d·ª´ng th·ªß c√¥ng
            if (!recognitionStoppedManually) {
                try {
                    recognition.start();
                    isRecording = true;
                    updateMicButtonState(true);
                    showStatus('recording', 'ƒêang nghe...');
                } catch (e) {
                    console.error("L·ªói khi kh·ªüi ƒë·ªông l·∫°i:", e);
                    showStatus('error', 'Kh√¥ng th·ªÉ ti·∫øp t·ª•c ghi √¢m');
                }
            } else {
                recognitionStoppedManually = false; // ƒê·∫∑t l·∫°i c·ªù
            }
        }

        // --- CH·ªàNH S·ª¨A VƒÇN B·∫¢N B·∫∞NG GEMINI API ---
        async function correctText(text, sourceLang) {
            if (!text || text.trim() === '') {
                return '';
            }

            showStatus('processing', 'ƒêang ch·ªânh s·ª≠a c√¢u...');

            try {
                const languageMap = {
                    'vi-VN': 'Vietnamese',
                    'en-US': 'English',
                    'ja-JP': 'Japanese'
                };

                const language = languageMap[sourceLang] || 'English';

                const prompt = `Please correct and improve this ${language} text for natural 
                      grammar, flow and accuracy. Only return the corrected text,
                      no explanations:\n\n"${text}"`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.2,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 1024,
                        }
                    })
                });

                const data = await response.json();

                if (data.candidates && data.candidates[0]?.content?.parts && data.candidates[0].content.parts[0]?.text) {
                    correctedText = data.candidates[0].content.parts[0].text.trim();
                    showStatus('success', 'ƒê√£ ch·ªânh s·ª≠a c√¢u');
                    return correctedText;
                } else {
                    throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ API');
                }
            } catch (error) {
                console.error('L·ªói khi ch·ªânh s·ª≠a c√¢u:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ ch·ªânh s·ª≠a c√¢u');
                return text; // Tr·∫£ v·ªÅ vƒÉn b·∫£n g·ªëc n·∫øu l·ªói
            }
        }

        // --- D·ªäCH VƒÇN B·∫¢N B·∫∞NG GEMINI API ---
        async function translateText(text, sourceLang, targetLang) {
            if (!text || text.trim() === '') {
                return '';
            }

            showStatus('processing', 'ƒêang d·ªãch c√¢u...');

            try {
                const languageMap = {
                    'vi-VN': 'Vietnamese',
                    'en-US': 'English',
                    'ja-JP': 'Japanese'
                };

                const sourceLanguage = languageMap[sourceLang] || 'Vietnamese';
                const targetLanguage = languageMap[targetLang] || 'English';

                const prompt = `Translate the following text from ${sourceLanguage} to ${targetLanguage}. 
                       Only respond with the translated text, nothing else:

                       ${text}`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.2,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 1024,
                        }
                    })
                });

                const data = await response.json();

                if (data.candidates && data.candidates[0]?.content?.parts && data.candidates[0].content.parts[0]?.text) {
                    translatedText = data.candidates[0].content.parts[0].text.trim();
                    showStatus('success', 'ƒê√£ d·ªãch c√¢u');
                    return translatedText;
                } else {
                    throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c b·∫£n d·ªãch t·ª´ API');
                }
            } catch (error) {
                console.error('L·ªói khi g·ªçi API d·ªãch:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ d·ªãch c√¢u');
                return ''; // Tr·∫£ v·ªÅ r·ªóng n·∫øu l·ªói
            }
        }

        // --- G·ª¢I √ù t·ª´ V·ª∞NG ---
        // --- G·ª¢I √ù t·ª´ V·ª∞NG ---
        async function suggestVocabulary(text, sourceLang) {
            if (!text || text.trim() === '') {
                return '<i>Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ g·ª£i √Ω t·ª´ v·ª±ng</i>';
            }

            showStatus('processing', 'ƒêang l·∫•y t·ª´ v·ª±ng...');

            try {
                const languageMap = {
                    'vi-VN': 'Vietnamese',
                    'en-US': 'English',
                    'ja-JP': 'Japanese'
                };

                const language = languageMap[sourceLang] || 'English';

                let prompt;
                if (sourceLang === 'ja-JP') {
                    prompt = `Extract Japanese vocabulary from this sentence in format: 
                    Kanji - Hiragana - Vietnamese meaning. 
                    If no vocabulary found, reply "No vocabulary". 
                    Only list vocabulary, no explanations:\n\n"${text}"`;
                } else {
                    prompt = `Extract important vocabulary words from this ${language} sentence 
                    with Vietnamese translations. Format each as: Word - Translation. 
                    If none, reply "No vocabulary". Only list words:\n\n"${text}"`;
                }

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.3,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 512,
                        }
                    })
                });

                const data = await response.json();

                if (!data.candidates || !data.candidates[0]?.content?.parts[0]?.text) {
                    throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c t·ª´ v·ª±ng t·ª´ API');
                }

                const rawText = data.candidates[0].content.parts[0].text.trim();

                if (rawText.toLowerCase().includes('no vocabulary')) {
                    return '<i>Kh√¥ng c√≥ t·ª´ v·ª±ng n√†o ƒë∆∞·ª£c ph√°t hi·ªán.</i>';
                }

                // X·ª≠ l√Ω k·∫øt qu·∫£ cho ti·∫øng Nh·∫≠t (3 c·ªôt)
                if (sourceLang === 'ja-JP') {
                    const rows = rawText.split('\n')
                        .filter(line => line.trim() && line.includes('-'))
                        .map(line => {
                            const parts = line.split('-').map(s => s.trim());
                            // ƒê·∫£m b·∫£o c√≥ ƒë·ªß 3 ph·∫ßn (Kanji - Hiragana - Nghƒ©a)
                            if (parts.length >= 3) {
                                return `<tr>
                            <td>${parts[0]}</td>
                            <td>${parts[1]}</td>
                            <td>${parts.slice(2).join(' - ')}</td>
                        </tr>`;
                            }
                            return ''; // B·ªè qua n·∫øu kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng
                        })
                        .filter(row => row !== ''); // L·ªçc b·ªè c√°c h√†ng tr·ªëng

                    return `
                <table border="1" cellpadding="5" style="border-collapse: collapse; width: 100%;">
                    <tr style="background-color: #222;">
                        <th>Kanji</th>
                        <th>Hiragana</th>
                        <th>Nghƒ©a</th>
                    </tr>
                    ${rows.join('\n')}
                </table>
            `;
                }
                // X·ª≠ l√Ω cho c√°c ng√¥n ng·ªØ kh√°c (2 c·ªôt)
                else {
                    const rows = rawText.split('\n')
                        .filter(line => line.trim() && line.includes('-'))
                        .map(line => {
                            const parts = line.split('-').map(s => s.trim());
                            return `<tr>
                        <td>${parts[0]}</td>
                        <td>${parts.slice(1).join(' - ')}</td>
                    </tr>`;
                        });

                    return `
                <table border="1" cellpadding="5" style="border-collapse: collapse; width: 100%;">
                    <tr style="background-color: #222;">
                        <th>T·ª´ v·ª±ng</th>
                        <th>Nghƒ©a</th>
                    </tr>
                    ${rows.join('\n')}
                </table>
            `;
                }

            } catch (error) {
                console.error('L·ªói khi l·∫•y t·ª´ v·ª±ng:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ l·∫•y t·ª´ v·ª±ng');
                return '<i>Kh√¥ng th·ªÉ l·∫•y t·ª´ v·ª±ng</i>';
            }
        }

        // --- C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI N√öT MIC ---
        function toggleRecognition() {
            if (isRecording) {
                stopRecognition();
            } else {
                startRecognition();
            }
        }

        // --- TOGGLE HI·ªÇN TH·ªä C√ÇU CH·ªàNH S·ª¨A ---
        async function toggleCorrectedText() {
            try {
                // L·∫•y vƒÉn b·∫£n hi·ªán t·∫°i
                const rawText = elements.resultBox.textContent.trim();

                if (!rawText) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ ch·ªânh s·ª≠a');
                    return;
                }

                // G·ªçi API ch·ªânh s·ª≠a vƒÉn b·∫£n
                const corrected = await correctText(rawText, currentLang);

                // Hi·ªÉn th·ªã trong corrected box
                elements.correctedBox.textContent = corrected;
                elements.correctedBox.classList.remove('hidden');

                // L∆∞u c√¢u ƒë√£ ch·ªânh s·ª≠a v√†o th·∫ª editable ƒë·ªÉ c√≥ th·ªÉ ch·ªânh s·ª≠a th√™m
                elements.editableText.value = corrected;

                showStatus('success', 'ƒê√£ hi·ªÉn th·ªã c√¢u ch·ªânh s·ª≠a');
            } catch (error) {
                console.error('L·ªói toggle ch·ªânh s·ª≠a:', error);
                showStatus('error', 'L·ªói khi hi·ªÉn th·ªã c√¢u ch·ªânh s·ª≠a');
            }
        }

        // --- TOGGLE HI·ªÇN TH·ªä D·ªäCH ---
        async function toggleTranslation() {
            try {
                // L·∫•y vƒÉn b·∫£n ƒë√£ ch·ªânh s·ª≠a ho·∫∑c vƒÉn b·∫£n g·ªëc n·∫øu ch∆∞a ch·ªânh s·ª≠a
                const textToTranslate = correctedText || elements.resultBox.textContent.trim();

                if (!textToTranslate) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ d·ªãch');
                    return;
                }

                // X√°c ƒë·ªãnh ng√¥n ng·ªØ ƒë√≠ch
                const targetLang = getTargetLanguage(currentLang);

                // G·ªçi API d·ªãch
                const translated = await translateText(textToTranslate, currentLang, targetLang);

                // Hi·ªÉn th·ªã trong translation box
                elements.translationText.textContent = translated;
                elements.translationBox.classList.remove('hidden');

                showStatus('success', 'ƒê√£ hi·ªÉn th·ªã b·∫£n d·ªãch');
            } catch (error) {
                console.error('L·ªói toggle d·ªãch:', error);
                showStatus('error', 'L·ªói khi hi·ªÉn th·ªã b·∫£n d·ªãch');
            }
        }

        // --- TOGGLE HI·ªÇN TH·ªä T·ª™ V·ª∞NG ---
        async function toggleVocabulary() {
            try {
                // L·∫•y vƒÉn b·∫£n ƒë√£ ch·ªânh s·ª≠a ho·∫∑c vƒÉn b·∫£n g·ªëc n·∫øu ch∆∞a ch·ªânh s·ª≠a
                const textForVocab = correctedText || elements.resultBox.textContent.trim();

                if (!textForVocab) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ g·ª£i √Ω t·ª´ v·ª±ng');
                    return;
                }

                // G·ªçi API g·ª£i √Ω t·ª´ v·ª±ng
                const vocabHTML = await suggestVocabulary(textForVocab, currentLang);

                // Hi·ªÉn th·ªã trong vocab box
                elements.vocabList.innerHTML = vocabHTML;
                elements.vocabBox.classList.remove('hidden');

                showStatus('success', 'ƒê√£ hi·ªÉn th·ªã g·ª£i √Ω t·ª´ v·ª±ng');
            } catch (error) {
                console.error('L·ªói toggle t·ª´ v·ª±ng:', error);
                showStatus('error', 'L·ªói khi hi·ªÉn th·ªã g·ª£i √Ω t·ª´ v·ª±ng');
            }
        }

        // --- L∆ØU VƒÄN B·∫¢N G·ªêC V√ÄO EDITABLE ---
        function saveToEditable() {
            try {
                // Th√™m n·ªôi dung hi·ªán t·∫°i v√†o editable
                const currentContent = elements.editableText.value.trim();
                const newContent = elements.resultBox.textContent.trim();

                if (!newContent) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ l∆∞u');
                    return;
                }

                // Th√™m d·∫•u xu·ªëng d√≤ng n·∫øu ƒë√£ c√≥ n·ªôi dung
                if (currentContent) {
                    elements.editableText.value = currentContent + '\n' + newContent;
                } else {
                    elements.editableText.value = newContent;
                }

                showStatus('success', 'ƒê√£ l∆∞u vƒÉn b·∫£n');
            } catch (error) {
                console.error('L·ªói khi l∆∞u vƒÉn b·∫£n:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ l∆∞u vƒÉn b·∫£n');
            }
        }

        // --- X√ìA T·∫§T C·∫¢ ---
        function clearAll() {
            try {
                // D·ª´ng ghi √¢m n·∫øu ƒëang ch·∫°y
                if (isRecording) {
                    stopRecognition();
                }

                // X√≥a n·ªôi dung c√°c ph·∫ßn t·ª≠
                elements.editableText.value = '';
                elements.resultBox.textContent = '';
                elements.correctedBox.textContent = '';
                elements.translationText.textContent = '';
                elements.vocabList.innerHTML = '';

                // ·∫®n c√°c box kh√¥ng c·∫ßn thi·∫øt
                elements.correctedBox.classList.add('hidden');
                elements.translationBox.classList.add('hidden');
                elements.vocabBox.classList.add('hidden');

                // Reset c√°c bi·∫øn tr·∫°ng th√°i
                finalTranscript = '';
                interimTranscript = '';
                correctedText = '';
                translatedText = '';

                showStatus('info', 'ƒê√£ x√≥a t·∫•t c·∫£ n·ªôi dung');
            } catch (error) {
                console.error('L·ªói khi x√≥a:', error);
                showStatus('error', 'L·ªói khi x√≥a n·ªôi dung');
            }
        }

        // --- PH√ÅT √ÇM B·∫¢N D·ªäCH ---
        function speakTranslation() {
            try {
                // X√°c ƒë·ªãnh vƒÉn b·∫£n c·∫ßn ph√°t √¢m
                const textToSpeak = elements.translationText.textContent.trim();

                if (!textToSpeak) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ ph√°t √¢m');
                    return;
                }

                // X√°c ƒë·ªãnh ng√¥n ng·ªØ cho ph√°t √¢m
                const speakLanguage = getTargetLanguage(currentLang);

                // Ph√°t √¢m b·∫±ng Web Speech API
                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                utterance.lang = speakLanguage;
                speechSynthesis.speak(utterance);

                showStatus('info', 'ƒêang ph√°t √¢m...');
            } catch (error) {
                console.error('L·ªói khi ph√°t √¢m:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ ph√°t √¢m');
            }
        }

        // --- X√ÅC ƒê·ªäNH NG√îN NG·ªÆ ƒê√çCH ---
        function getTargetLanguage(sourceLang) {
            switch (sourceLang) {
                case 'vi-VN':
                    return 'en-US'; // Ti·∫øng Vi·ªát -> Ti·∫øng Anh
                case 'en-US':
                    return 'vi-VN'; // Ti·∫øng Anh -> Ti·∫øng Vi·ªát
                case 'ja-JP':
                    return 'vi-VN'; // Ti·∫øng Nh·∫≠t -> Ti·∫øng Vi·ªát
                default:
                    return 'en-US';
            }
        }

        // --- THAY ƒê·ªîI NG√îN NG·ªÆ ---
        function changeLanguage(newLang) {
            currentLang = newLang;

            // C·∫≠p nh·∫≠t UI
            updateUILanguage(newLang);

            // C·∫≠p nh·∫≠t c·∫•u h√¨nh nh·∫≠n d·∫°ng gi·ªçng n√≥i
            if (recognition) {
                const wasRecording = isRecording;

                // D·ª´ng nh·∫≠n d·∫°ng hi·ªán t·∫°i
                if (wasRecording) {
                    stopRecognition();
                }

                // C·∫≠p nh·∫≠t ng√¥n ng·ªØ
                recognition.lang = newLang;

                // Kh·ªüi ƒë·ªông l·∫°i n·∫øu ƒëang ho·∫°t ƒë·ªông
                if (wasRecording) {
                    setTimeout(() => startRecognition(), 300);
                }
            }

            showStatus('info', `ƒê√£ chuy·ªÉn ng√¥n ng·ªØ th√†nh ${getLanguageDisplayName(newLang)}`);
        }

        // --- T√äN HI·ªÇN TH·ªä CHO NG√îN NG·ªÆ ---
        function getLanguageDisplayName(langCode) {
            const names = {
                'vi-VN': 'Ti·∫øng Vi·ªát',
                'en-US': 'Ti·∫øng Anh',
                'ja-JP': 'Ti·∫øng Nh·∫≠t'
            };
            return names[langCode] || langCode;
        }

        // --- LI√äN K·∫æT S·ª∞ KI·ªÜN V·ªöI C√ÅC N√öT ---
        // C√°c h√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi khi s·ª± ki·ªán click x·∫£y ra

        // N√∫t micro
        function onMicButtonClick() {
            toggleRecognition();
        }

        // N√∫t hi·ªÉn th·ªã c√¢u ch·ªânh s·ª≠a
        function onCorrectionButtonClick() {
            toggleCorrectedText();
        }

        // N√∫t hi·ªÉn th·ªã b·∫£n d·ªãch
        function onTranslateButtonClick() {
            toggleTranslation();
        }

        // N√∫t hi·ªÉn th·ªã t·ª´ v·ª±ng
        function onVocabButtonClick() {
            toggleVocabulary();
        }

        // N√∫t l∆∞u vƒÉn b·∫£n
        function onSaveButtonClick() {
            saveToEditable();
        }

        // N√∫t x√≥a t·∫•t c·∫£
        function onClearButtonClick() {
            clearAll();
        }

        // N√∫t ph√°t √¢m
        function onSpeakButtonClick() {
            speakTranslation();
        }

        // N√∫t chuy·ªÉn tab ng√¥n ng·ªØ
        function onLanguageTabClick(langCode) {
            changeLanguage(langCode);
        }

        // --- C·∫¨P NH·∫¨T UI THEO NG√îN NG·ªÆ ---
        function updateUILanguage(langCode) {
            // X√≥a tr·∫°ng th√°i active kh·ªèi t·∫•t c·∫£ c√°c tab
            for (const key in elements.langTabs) {
                elements.langTabs[key].classList.remove('active');
            }

            // ƒê·∫∑t tr·∫°ng th√°i active cho tab hi·ªán t·∫°i
            switch (langCode) {
                case 'vi-VN':
                    elements.langTabs.vi.classList.add('active');
                    break;
                case 'en-US':
                    elements.langTabs.en.classList.add('active');
                    break;
                case 'ja-JP':
                    elements.langTabs.ja.classList.add('active');
                    break;
            }
        }

        // --- X·ª¨ L√ù L·ªñI NH·∫¨N D·∫†NG ---
        function handleRecognitionError(event) {
            console.error("L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i:", event.error);

            let errorMessage = "L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i";
            switch (event.error) {
                case 'no-speech':
                    errorMessage = "Kh√¥ng ph√°t hi·ªán gi·ªçng n√≥i";
                    break;
                case 'audio-capture':
                    errorMessage = "Kh√¥ng th·ªÉ truy c·∫≠p microphone";
                    break;
                case 'not-allowed':
                    errorMessage = "Quy·ªÅn truy c·∫≠p microphone b·ªã t·ª´ ch·ªëi";
                    break;
                case 'network':
                    errorMessage = "L·ªói k·∫øt n·ªëi m·∫°ng";
                    break;
                case 'aborted':
                    errorMessage = "Nh·∫≠n d·∫°ng b·ªã h·ªßy";
                    break;
                case 'language-not-supported':
                    errorMessage = "Ng√¥n ng·ªØ kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£";
                    break;
            }

            showStatus('error', errorMessage);
            isRecording = false;
            updateMicButtonState(false);
        }

        // --- X·ª¨ L√ù KHI B·∫ÆT ƒê·∫¶U NH·∫¨N D·∫†NG ---
        function handleRecognitionStart() {
            showStatus('recording', 'ƒêang nghe...');
            isRecording = true;
            updateMicButtonState(true);
        }

        // --- HI·ªÇN TH·ªä TR·∫†NG TH√ÅI ---
        function showStatus(type, message) {
            // Lo·∫°i b·ªè t·∫•t c·∫£ c√°c class tr·∫°ng th√°i hi·ªán t·∫°i
            elements.statusBar.classList.remove('recording', 'error', 'success', 'warning', 'info', 'processing');

            // Th√™m class m·ªõi t∆∞∆°ng ·ª©ng v·ªõi lo·∫°i tr·∫°ng th√°i
            elements.statusBar.classList.add(type);

            // C·∫≠p nh·∫≠t n·ªôi dung
            elements.statusMessage.textContent = message;
        }


        // --- C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI N√öT MIC ---
        function updateMicButtonState(isActive) {
            const micButton = elements.micButton;

            if (isActive) {
                micButton.classList.add('active');
                micButton.innerHTML = 'üõë D·ª´ng';
            } else {
                micButton.classList.remove('active');
                micButton.innerHTML = 'üéôÔ∏è Ghi √¢m';
            }
        }
	</script>
</body>
</html>
